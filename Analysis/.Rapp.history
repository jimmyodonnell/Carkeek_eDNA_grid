ks.test((counts_mat)/rowSums(counts_mat), prop_true_small)
counts_mat
t(counts_mat)/rowSums(t(counts_mat))
rowSums(t(counts_mat)/rowSums(t(counts_mat)))
rowSums(prop_true_small)
ks.test(t(counts_mat)/rowSums(t(counts_mat)), prop_true_small)
prop_true_small
counts_vec
counts_mat
counts
names(counts_mat) <- taxon_names
counts_mat
set.seed(407744)#
counts_mat <- apply(#
					X = eDNA_counts_small, #
					MARGIN = 1, #
					FUN = function(x) #
						rmultinom(size = N_draws, prob = x, n = 1)#
				)
#############################################################################
# This script simulates some data that resembles eDNA sequence data#
#############################################################################
#
# Original code by Ole Shelton#
# Hacked up by Jimmy O'Donnell#
# Comments mostly reflect Jimmy's imperfect understanding of the underlying concepts.#
#
library(gtools) # gtools::rdirichlet#
library(R2jags) # R2jags::jags#
# Suppose we have an aquarium which contains N_tax taxa#
N_tax <- 9#
# Give them names#
taxon_names <- paste("taxon_", LETTERS[1:N_tax], sep = "")#
# The distribution of DNA molecules derived from each of the taxa might look like the following#
# Ole originally called these alpha because they eventually become the alpha parameter of the Dirichlet distribution, which sorta determines how likely each component is to be drawn#
# I call these "true" because they represent the "true" abundance of DNA from each taxon in the sample.#
# Set seed to be able to reproduce draws from a probability distribution (gets reset each time one of these functions is used)#
# Instead of runif, you might try using rexp or random from the Pareto distribution to more accurately resemble "real" eDNA results#
set.seed(407744)#
DNA_truth		<- sort(round(runif(N_tax,1,100)), decreasing = TRUE)#
names(DNA_truth) <- taxon_names#
#
# those same values expressed as proportions#
DNA_truth_prop <- DNA_truth/sum(DNA_truth)#
#############################################################################
# The actual simulation #
#############################################################################
#
# This simulates data that might be expected from high throughput sequencing of PCR amplicons generated from environmental samples: proportional abundance of sequences from each of the taxa/OTUs/dups#
# draw samples from the Dirichlet distribution, using alpha given by DNA_truth to approximate the sampling of DNA molecules from the environment#
# Set seed to be able to reproduce draws from a probability distribution (gets reset each time one of these functions is used)#
# How many times should we sample?#
N_samples_small	<-	3#
set.seed(407744)#
eDNA_counts_small <- rdirichlet(N_samples_small, DNA_truth)#
colnames(eDNA_counts_small) <- taxon_names#
#############
# OR...#
#############
N_samples_big		<- 100000#
set.seed(407744)#
eDNA_counts_big <- rdirichlet(N_samples_big, DNA_truth)#
colnames(eDNA_counts_big) <- taxon_names#
# Set whichever of these as the plot input:#
plot_input <- eDNA_counts_big#
#
# Create plot layout (this looks complicated to allow it to be flexible to different taxa numbers)#
plot_cols <- ceiling(sqrt(ncol(plot_input)))#
plot_rows <- ceiling(ncol(plot_input)/plot_cols)#
plot_layout <- matrix(data = 1:(plot_cols*plot_rows), nrow = plot_rows, byrow = TRUE)#
layout(plot_layout)#
#
# plot histograms of the frequency of proportions sampled for each taxon.#
for (i in 1:ncol(plot_input)){#
  hist(plot_input[, i], main = taxon_names[i], xlab = "proportion")#
  abline(v = DNA_truth_prop[i], col = "red")#
}#
# In a similar way, we can use each of the samples to inform the probabilities of draws from a multinomial distribution. This produces data that is functionally indistinguishable from that presented above.#
# Using each row of the "true proportion" data frame as probabilities...#
# essentially: take a draw of 'N_draws' marbles, #
# and put them into each of some number of bins #
# with probability of going into each bin given by the "true proportion" row#
# (repeat n times)#
#
N_draws		<-	100000#
#
set.seed(407744)#
counts_mat <- apply(#
					X = eDNA_counts_small, #
					MARGIN = 1, #
					FUN = function(x) #
						rmultinom(size = N_draws, prob = x, n = 1)#
				)
counts_mat
rownames(counts_mat) <- taxon_names
counts_mat
counts <- t(counts_mat)
counts
counts_vec <- as.vector(counts)
counts_vec
names(counts_vec) <- rep(x = taxon_names, each = N_samples_small)
counts_vec
mydata <- counts
mydata
dput(mydata)
counts <- mydata
colnames(counts)
names(counts_vec) <- rep(x = colnames(counts), each = nrow(counts))
counts_vec
nrow(counts)
length(counts)
length(counts_vec)
library(gtools) # gtools::rdirichlet#
library(R2jags) # R2jags::jags#
# Suppose we have an aquarium which contains N_tax taxa#
N_tax <- 9#
# Give them names#
taxon_names <- paste("taxon_", LETTERS[1:N_tax], sep = "")#
# The distribution of DNA molecules derived from each of the taxa might look like the following#
# Ole originally called these alpha because they eventually become the alpha parameter of the Dirichlet distribution, which sorta determines how likely each component is to be drawn#
# I call these "true" because they represent the "true" abundance of DNA from each taxon in the sample.#
# Set seed to be able to reproduce draws from a probability distribution (gets reset each time one of these functions is used)#
# Instead of runif, you might try using rexp or random from the Pareto distribution to more accurately resemble "real" eDNA results#
set.seed(407744)#
DNA_truth		<- sort(round(runif(N_tax,1,100)), decreasing = TRUE)#
names(DNA_truth) <- taxon_names#
#
# those same values expressed as proportions#
DNA_truth_prop <- DNA_truth/sum(DNA_truth)#
#############################################################################
# The actual simulation #
#############################################################################
#
# This simulates data that might be expected from high throughput sequencing of PCR amplicons generated from environmental samples: proportional abundance of sequences from each of the taxa/OTUs/dups#
# draw samples from the Dirichlet distribution, using alpha given by DNA_truth to approximate the sampling of DNA molecules from the environment#
# Set seed to be able to reproduce draws from a probability distribution (gets reset each time one of these functions is used)#
# How many times should we sample?#
N_samples_small	<-	3#
set.seed(407744)#
eDNA_counts_small <- rdirichlet(N_samples_small, DNA_truth)#
colnames(eDNA_counts_small) <- taxon_names#
#############
# OR...#
#############
N_samples_big		<- 100000#
set.seed(407744)#
eDNA_counts_big <- rdirichlet(N_samples_big, DNA_truth)#
colnames(eDNA_counts_big) <- taxon_names#
# Set whichever of these as the plot input:#
plot_input <- eDNA_counts_big#
#
# Create plot layout (this looks complicated to allow it to be flexible to different taxa numbers)#
plot_cols <- ceiling(sqrt(ncol(plot_input)))#
plot_rows <- ceiling(ncol(plot_input)/plot_cols)#
plot_layout <- matrix(data = 1:(plot_cols*plot_rows), nrow = plot_rows, byrow = TRUE)#
layout(plot_layout)#
#
# plot histograms of the frequency of proportions sampled for each taxon.#
for (i in 1:ncol(plot_input)){#
  hist(plot_input[, i], main = taxon_names[i], xlab = "proportion")#
  abline(v = DNA_truth_prop[i], col = "red")#
}#
# In a similar way, we can use each of the samples to inform the probabilities of draws from a multinomial distribution. This produces data that is functionally indistinguishable from that presented above.#
# Using each row of the "true proportion" data frame as probabilities...#
# essentially: take a draw of 'N_draws' marbles, #
# and put them into each of some number of bins #
# with probability of going into each bin given by the "true proportion" row#
# (repeat n times)#
#
N_draws		<-	100000#
#
set.seed(407744)#
counts_mat <- apply(#
					X = eDNA_counts_small, #
					MARGIN = 1, #
					FUN = function(x) #
						rmultinom(size = N_draws, prob = x, n = 1)#
				)#
#
# assign names#
rownames(counts_mat) <- taxon_names#
#
# transpose#
counts <- t(counts_mat)#
#
mydata <- counts
counts <- mydata#
#
# make into a vector#
counts_vec <- as.vector(counts)#
names(counts_vec) <- rep(x = colnames(counts), each = nrow(counts))#
# want to save the file?
write.csv(x = counts, file = "counts.csv")
write.csv(x = counts, file = "counts.csv", row.names = FALSE)
write.csv(x = counts, file = "counts.csv", row.names = FALSE, quotes = FALSE)
write.csv(x = counts, file = "counts.csv", row.names = FALSE, quote = FALSE)
counts <- mydata
counts_vec <- as.vector(counts)#
names(counts_vec) <- rep(x = colnames(counts), each = nrow(counts))
as.matrix(mydata)
identical(counts, as.matrix(mydata))
mydata <- as.matrix(read.csv("counts.csv"))
identical(mydata, counts)
par(mfrow = c(3,3))#
for(i in 1:9){#
	plot(#
		sort(#
			rexp(#
				n = 100, #
				rate = i#
				)#
			)#
		, #
		main = paste("rate = ", i, sep = ""), #
		ylim = c(0,5), #
		pch = 20, #
		cex = 0.5#
	)#
}
dpareto <- function(x, xm, alpha) ifelse(x > xm , alpha*xm**alpha/(x**(alpha+1)), 0)#
ppareto <- function(q, xm, alpha) ifelse(q > xm , 1 - (xm/q)**alpha, 0 )#
qpareto <- function(p, xm, alpha) ifelse(p < 0 | p > 1, NaN, xm*(1-p)**(-1/alpha))#
rpareto <- function(n, xm, alpha) qpareto(runif(n), xm, alpha)#
#
par(mfrow = c(3,3))#
#
for(i in 1:9){#
	plot(#
		sort(#
			rpareto(#
				100, i, 2#
			)#
		)#
		, ylim = c(0, 15)#
	)#
}#
# xm simply determines the minimum value drawn#
#
for(i in 1:9){#
	plot(#
		sort(#
			rpareto(#
				100, 1, i#
			)#
		)#
		, ylim = c(0, 15)#
	)#
}
for(i in 1:9){#
	plot(#
		sort(#
			rpareto(#
				100, i, 2#
			)#
		)#
		, ylim = c(0, 15)#
	)#
}
for(i in 1:9){#
	plot(#
		sort(#
			rpareto(#
				100, i, 2#
			)#
		)#
		, ylim = c(0, 15), #
		main = paste("xm = ", i, sep = "")#
	)#
}
for(i in 1:9){#
	plot(#
		sort(#
			rpareto(#
				n = 100, xm = 1, alpha = i#
			)#
		)#
		, ylim = c(0, 15), #
		main = paste("alph = ", i, sep = "")#
	)#
}
for(i in 1:9){#
	plot(#
		sort(#
			rpareto(#
				n = 100, xm = 1, alpha = i#
			)#
		)#
		, ylim = c(0, 15), #
		main = paste("alpha = ", i, sep = "")#
	)#
}
library(gtools) # gtools::rdirichlet#
library(R2jags) # R2jags::jags#
# Suppose we have an aquarium which contains N_tax taxa#
N_tax <- 9#
# Give them names#
taxon_names <- paste("taxon_", LETTERS[1:N_tax], sep = "")
set.seed(407744)#
DNA_truth		<- sort(round(runif(N_tax,1,100)), decreasing = TRUE)#
names(DNA_truth) <- taxon_names#
#
# those same values expressed as proportions#
DNA_truth_prop <- DNA_truth/sum(DNA_truth)
N_samples_small	<-	3#
set.seed(407744)#
eDNA_counts_small <- rdirichlet(N_samples_small, DNA_truth)#
colnames(eDNA_counts_small) <- taxon_names
N_samples_big		<- 100000#
set.seed(407744)#
eDNA_counts_big <- rdirichlet(N_samples_big, DNA_truth)#
colnames(eDNA_counts_big) <- taxon_names
plot_input <- eDNA_counts_big
plot_cols <- ceiling(sqrt(ncol(plot_input)))#
plot_rows <- ceiling(ncol(plot_input)/plot_cols)#
plot_layout <- matrix(data = 1:(plot_cols*plot_rows), nrow = plot_rows, byrow = TRUE)#
layout(plot_layout)
for (i in 1:ncol(plot_input)){#
  hist(plot_input[, i], main = taxon_names[i], xlab = "proportion")#
  abline(v = DNA_truth_prop[i], col = "red")#
}
N_draws		<-	100000
set.seed(407744)#
counts_mat <- apply(#
					X = eDNA_counts_small, #
					MARGIN = 1, #
					FUN = function(x) #
						rmultinom(size = N_draws, prob = x, n = 1)#
				)
rownames(counts_mat) <- taxon_names
counts <- t(counts_mat)
mydata <- counts
counts <- as.matrix(mydata)
counts_vec <- as.vector(counts)#
names(counts_vec) <- rep(x = colnames(counts), each = nrow(counts))
cat_mat <- matrix(data = 0, nrow = length(counts_vec), ncol = ncol(counts))
cat_mat[,1]	<- 1
for(i in 1:length(taxon_names)){#
	same_taxon <- which(rep(1:length(taxon_names), each = N_samples_small) == i)#
	cat_mat[same_taxon,i]	<-	1#
	# Ole's solution is more readable (x <- 1), but you can also make use of the fact that logical vectors (T/F) can be expressed as 1/0 using as.integer#
	# as.integer(rep(1:length(taxon_names), each = N_samples_small) == i)#
}#
colnames(cat_mat)	<-	taxon_names
cat_mat
var_mat	<-	matrix(data = 0, nrow = length(counts_vec), ncol = length(taxon_names))#
#
for(i in 1:length(taxon_names)){#
	same_taxon <- which(rep(1:length(taxon_names), each = N_samples_small) == i)#
	var_mat[same_taxon, i]	<-	1#
}#
colnames(var_mat) <- taxon_names
betas	<- rep(0, ncol(cat_mat))
N_cov	<-	length(taxon_names)#
N_obs	<-	length(counts_vec)
N_cov
N_obs
iden_mat <- diag(x = 1, nrow = N_obs)
jags_data <- list("counts_vec", "N_obs", "N_cov", "cat_mat")#
#
# WHAT IS P?#
jags_params <- c("betas", "P")#
#
# I think this is telling where the script lives?#
model_loc <- c("my_jags_script.txt")#
#
# Set the number of iterations to discard before storing them#
N_burn <- 10000#
#
# Set the total number of iterations to conduct (total? or after burnin?)#
N_iter <- 10000#
# write the JAGS script:#
jagsscript <- cat(#
"model {#
	for(i in 1:N_obs){#
		counts_vec[i] ~ dpois(exp(lambda[i]))#
	}#
	lambda <- cat_mat %*% betas #+ eta#
	### Derived Quantities#
	p[1] <- exp(betas[1])#
	for(i in 2:N_cov){#
		p[i] <- exp(betas[1] + betas[i])#
	}#
	# This can probably just be: P <- p / sum(p)#
	for(i in 1:N_cov){#
		P[i] <- p[i] / sum(p)#
	}#
	### PRIORS#
	for(j in 1:N_cov){#
		betas[j] ~ dnorm(0, 0.001)#
	}#
}", file = model_loc)#
#
) # cat doesn't close until I make this parentheses...#
)
my_jags_model <- jags(#
					data = jags_data, #
					inits = NULL, #
					parameters.to.save = jags_params, #
					model.file = model_loc, #
					n.chains = 3, #
					n.iter = N_iter + N_burn, #
					n.burnin = N_burn, #floor(n.iter/2) #
					n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
					DIC = TRUE, #
					working.directory = NULL, #
					jags.seed = 123, #
					refresh = N_iter/50, #
					progress.bar = "text", #
					digits = 5, #
					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"), #
					jags.module = c("glm","dic")#
)
attach.jags(my_jags_model, overwrite = TRUE)
?attach.jags
#############################################################################
# This script simulates some data that resembles eDNA sequence data#
#############################################################################
#
# Original code by Ole Shelton#
# Hacked up by Jimmy O'Donnell#
# Comments mostly reflect Jimmy's imperfect understanding of the underlying concepts.#
#
library(gtools) # gtools::rdirichlet#
library(R2jags) # R2jags::jags#
# Suppose we have an aquarium which contains N_tax taxa#
N_tax <- 9#
# Give them names#
taxon_names <- paste("taxon_", LETTERS[1:N_tax], sep = "")#
# The distribution of DNA molecules derived from each of the taxa might look like the following#
# Ole originally called these alpha because they eventually become the alpha parameter of the Dirichlet distribution, which sorta determines how likely each component is to be drawn#
# I call these "true" because they represent the "true" abundance of DNA from each taxon in the sample.#
# Set seed to be able to reproduce draws from a probability distribution (gets reset each time one of these functions is used)#
# Instead of runif, you might try using rexp or random from the Pareto distribution to more accurately resemble "real" eDNA results#
set.seed(407744)#
DNA_truth		<- sort(round(runif(N_tax,1,100)), decreasing = TRUE)#
names(DNA_truth) <- taxon_names#
#
# those same values expressed as proportions#
DNA_truth_prop <- DNA_truth/sum(DNA_truth)#
#############################################################################
# The actual simulation #
#############################################################################
#
# This simulates data that might be expected from high throughput sequencing of PCR amplicons generated from environmental samples: proportional abundance of sequences from each of the taxa/OTUs/dups#
# draw samples from the Dirichlet distribution, using alpha given by DNA_truth to approximate the sampling of DNA molecules from the environment#
# Set seed to be able to reproduce draws from a probability distribution (gets reset each time one of these functions is used)#
# If you were to take N_samples samples, what kind of answer would you expect?#
N_samples_small	<-	3#
set.seed(407744)#
eDNA_counts_small <- rdirichlet(N_samples_small, DNA_truth)#
colnames(eDNA_counts_small) <- taxon_names#
#############
# OR...#
#############
N_samples_big		<- 100000#
set.seed(407744)#
eDNA_counts_big <- rdirichlet(N_samples_big, DNA_truth)#
colnames(eDNA_counts_big) <- taxon_names#
# Set whichever of these as the plot input:#
plot_input <- eDNA_counts_big#
#
# Create plot layout (this looks complicated to allow it to be flexible to different taxa numbers)#
plot_cols <- ceiling(sqrt(ncol(plot_input)))#
plot_rows <- ceiling(ncol(plot_input)/plot_cols)#
plot_layout <- matrix(data = 1:(plot_cols*plot_rows), nrow = plot_rows, byrow = TRUE)#
layout(plot_layout)#
#
# plot histograms of the frequency of proportions sampled for each taxon.#
for (i in 1:ncol(plot_input)){#
  hist(plot_input[, i], main = taxon_names[i], xlab = "proportion")#
  abline(v = DNA_truth_prop[i], col = "red")#
}#
# In a similar way, we can use each of the samples to inform the probabilities of draws from a multinomial distribution. This produces data that is functionally indistinguishable from that presented above.#
# Using each row of the "true proportion" data frame as probabilities...#
# essentially: take a draw of 'N_draws' marbles, #
# and put them into each of some number of bins #
# with probability of going into each bin given by the "true proportion" row#
# (repeat n times)#
#
N_draws		<-	100000#
#
set.seed(407744)#
counts_mat <- apply(#
					X = eDNA_counts_small, #
					MARGIN = 1, #
					FUN = function(x) #
						rmultinom(size = N_draws, prob = x, n = 1)#
				)#
#
# assign names#
rownames(counts_mat) <- taxon_names#
#
# transpose#
counts <- t(counts_mat)#
#
# want to save the file?#
write.csv(x = counts, file = "counts.csv", row.names = FALSE, quote = FALSE)
?plot
N_tax <- 9
taxon_names <- paste("taxon_", LETTERS[1:N_tax], sep = "")#
# The distribution of DNA molecules derived from each of the taxa might look like the following#
# Ole originally called these alpha because they eventually become the alpha parameter of the Dirichlet distribution, which sorta determines how likely each component is to be drawn#
# I call these "true" because they represent the "true" abundance of DNA from each taxon in the sample.#
# Set seed to be able to reproduce draws from a probability distribution (gets reset each time one of these functions is used)#
# Instead of runif, you might try using rexp or random from the Pareto distribution to more accurately resemble "real" eDNA results#
set.seed(407744)#
DNA_truth		<- sort(round(runif(N_tax,1,100)), decreasing = TRUE)#
names(DNA_truth) <- taxon_names#
#
# those same values expressed as proportions#
DNA_truth_prop <- DNA_truth/sum(DNA_truth)#
#############################################################################
# The actual simulation #
#############################################################################
#
# This simulates data that might be expected from high throughput sequencing of PCR amplicons generated from environmental samples: proportional abundance of sequences from each of the taxa/OTUs/dups#
# draw samples from the Dirichlet distribution, using alpha given by DNA_truth to approximate the sampling of DNA molecules from the environment#
# Set seed to be able to reproduce draws from a probability distribution (gets reset each time one of these functions is used)#
# If you were to take N_samples samples, what kind of answer would you expect?#
N_samples_small	<-	3#
set.seed(407744)#
eDNA_counts_small <- rdirichlet(N_samples_small, DNA_truth)#
colnames(eDNA_counts_small) <- taxon_names#
#############
# OR...#
#############
N_samples_big		<- 100000#
set.seed(407744)#
eDNA_counts_big <- rdirichlet(N_samples_big, DNA_truth)#
colnames(eDNA_counts_big) <- taxon_names#
# Set whichever of these as the plot input:#
plot_input <- eDNA_counts_big#
#
# Create plot layout (this looks complicated to allow it to be flexible to different taxa numbers)#
plot_cols <- ceiling(sqrt(ncol(plot_input)))#
plot_rows <- ceiling(ncol(plot_input)/plot_cols)#
plot_layout <- matrix(data = 1:(plot_cols*plot_rows), nrow = plot_rows, byrow = TRUE)#
layout(plot_layout)#
#
# plot histograms of the frequency of proportions sampled for each taxon.#
for (i in 1:ncol(plot_input)){#
  hist(plot_input[, i], main = taxon_names[i], xlab = "proportion")#
  abline(v = DNA_truth_prop[i], col = "red")#
}
#############################################################################
# This script simulates some data that resembles eDNA sequence data#
#############################################################################
#
# Original code by Ole Shelton#
# Hacked up by Jimmy O'Donnell#
# Comments mostly reflect Jimmy's imperfect understanding of the underlying concepts.#
#
library(gtools) # gtools::rdirichlet#
library(R2jags) # R2jags::jags#
# Suppose we have an aquarium which contains N_tax taxa#
N_tax <- 9#
# Give them names#
taxon_names <- paste("taxon_", LETTERS[1:N_tax], sep = "")#
# The distribution of DNA molecules derived from each of the taxa might look like the following#
# Ole originally called these alpha because they eventually become the alpha parameter of the Dirichlet distribution, which sorta determines how likely each component is to be drawn#
# I call these "true" because they represent the "true" abundance of DNA from each taxon in the sample.#
# Set seed to be able to reproduce draws from a probability distribution (gets reset each time one of these functions is used)#
# Instead of runif, you might try using rexp or random from the Pareto distribution to more accurately resemble "real" eDNA results#
set.seed(407744)#
DNA_truth		<- sort(round(runif(N_tax,1,100)), decreasing = TRUE)#
names(DNA_truth) <- taxon_names#
#
# those same values expressed as proportions#
DNA_truth_prop <- DNA_truth/sum(DNA_truth)#
#############################################################################
# The actual simulation #
#############################################################################
#
# This simulates data that might be expected from high throughput sequencing of PCR amplicons generated from environmental samples: proportional abundance of sequences from each of the taxa/OTUs/dups#
# draw samples from the Dirichlet distribution, using alpha given by DNA_truth to approximate the sampling of DNA molecules from the environment#
# Set seed to be able to reproduce draws from a probability distribution (gets reset each time one of these functions is used)#
# If you were to take N_samples samples, what kind of answer would you expect?#
N_samples_small	<-	3#
set.seed(407744)#
eDNA_counts_small <- rdirichlet(N_samples_small, DNA_truth)#
colnames(eDNA_counts_small) <- taxon_names#
#############
# OR...#
#############
N_samples_big		<- 100000#
set.seed(407744)#
eDNA_counts_big <- rdirichlet(N_samples_big, DNA_truth)#
colnames(eDNA_counts_big) <- taxon_names#
# Set whichever of these as the plot input:#
plot_input <- eDNA_counts_big#
#
# Create plot layout (this looks complicated to allow it to be flexible to different taxa numbers)#
plot_cols <- ceiling(sqrt(ncol(plot_input)))#
plot_rows <- ceiling(ncol(plot_input)/plot_cols)#
plot_layout <- matrix(data = 1:(plot_cols*plot_rows), nrow = plot_rows, byrow = TRUE)#
layout(plot_layout)#
#
# plot histograms of the frequency of proportions sampled for each taxon.#
for (i in 1:ncol(plot_input)){#
  hist(plot_input[, i], main = taxon_names[i], xlab = "proportion")#
  abline(v = DNA_truth_prop[i], col = "red")#
}#
# In a similar way, we can use each of the samples to inform the probabilities of draws from a multinomial distribution. This produces data that is functionally indistinguishable from that presented above.#
# Using each row of the "true proportion" data frame as probabilities...#
# essentially: take a draw of 'N_draws' marbles, #
# and put them into each of some number of bins #
# with probability of going into each bin given by the "true proportion" row#
# (repeat n times)#
#
N_draws		<-	100000#
#
set.seed(407744)#
counts_mat <- apply(#
					X = eDNA_counts_small, #
					MARGIN = 1, #
					FUN = function(x) #
						rmultinom(size = N_draws, prob = x, n = 1)#
				)#
#
# assign names#
rownames(counts_mat) <- taxon_names#
#
# transpose#
counts <- t(counts_mat)#
#
# want to save the file?#
write.csv(x = counts, file = "counts.csv", row.names = FALSE, quote = FALSE)#
#
# or to prepare for next step (MCMC),#
mydata <- counts#
#
#############################################################################
# This marks the end of generating what I think of as typical eDNA sequence data
N_tax <- 13
# Give them names#
taxon_names <- paste("taxon_", LETTERS[1:N_tax], sep = "")#
# The distribution of DNA molecules derived from each of the taxa might look like the following#
# Ole originally called these alpha because they eventually become the alpha parameter of the Dirichlet distribution, which sorta determines how likely each component is to be drawn#
# I call these "true" because they represent the "true" abundance of DNA from each taxon in the sample.#
# Set seed to be able to reproduce draws from a probability distribution (gets reset each time one of these functions is used)#
# Instead of runif, you might try using rexp or random from the Pareto distribution to more accurately resemble "real" eDNA results#
set.seed(407744)#
DNA_truth		<- sort(round(runif(N_tax,1,100)), decreasing = TRUE)#
names(DNA_truth) <- taxon_names#
#
# those same values expressed as proportions#
DNA_truth_prop <- DNA_truth/sum(DNA_truth)#
#############################################################################
# The actual simulation #
#############################################################################
#
# This simulates data that might be expected from high throughput sequencing of PCR amplicons generated from environmental samples: proportional abundance of sequences from each of the taxa/OTUs/dups#
# draw samples from the Dirichlet distribution, using alpha given by DNA_truth to approximate the sampling of DNA molecules from the environment#
# Set seed to be able to reproduce draws from a probability distribution (gets reset each time one of these functions is used)#
# If you were to take N_samples samples, what kind of answer would you expect?#
N_samples_small	<-	3#
set.seed(407744)#
eDNA_counts_small <- rdirichlet(N_samples_small, DNA_truth)#
colnames(eDNA_counts_small) <- taxon_names#
#############
# OR...#
#############
N_samples_big		<- 100000#
set.seed(407744)#
eDNA_counts_big <- rdirichlet(N_samples_big, DNA_truth)#
colnames(eDNA_counts_big) <- taxon_names#
# Set whichever of these as the plot input:#
plot_input <- eDNA_counts_big#
#
# Create plot layout (this looks complicated to allow it to be flexible to different taxa numbers)#
plot_cols <- ceiling(sqrt(ncol(plot_input)))#
plot_rows <- ceiling(ncol(plot_input)/plot_cols)#
plot_layout <- matrix(data = 1:(plot_cols*plot_rows), nrow = plot_rows, byrow = TRUE)#
layout(plot_layout)#
#
# plot histograms of the frequency of proportions sampled for each taxon.#
for (i in 1:ncol(plot_input)){#
  hist(plot_input[, i], main = taxon_names[i], xlab = "proportion")#
  abline(v = DNA_truth_prop[i], col = "red")#
}
rm(list = ls())		# clear objects#
graphics.off() 		# close graphics windows #
#
# Generate data#
x = 0:10;#
y = 0:10;
rm(list = ls())		# clear objects#
graphics.off() 		# close graphics windows #
#
# Plot 3#
par(oma=c(3,3,3,3))
nf <- layout(matrix(c(2,0,1,3),2,2,byrow=TRUE), widths=c(6,1), heights=c(1,6), TRUE)
nf
layout.show(nf)
par(oma=c(3,3,3,3))
nf <- layout(matrix(c(2,0,1,3),2,2,byrow=TRUE), widths=c(6,1), heights=c(1,6), TRUE)#
#
# If you want to see your layout, this command will create a chart labelling it clearly.#
layout.show(nf)
par(mar=c(4,4,1,1))#
plot(0:10, 0:10, type="n", xlab="X", ylab="Y", col="green")#
box("figure", col="green")#
text(5,5,"Plot 1", col="green", cex=2)
par()
length_fragment <- 200
mass_bp <- 650
avo_num <- 6.022e23
num_copies <- function(length_fragment, mass_fragment){#
	# average mass of a single base pair (in Daltons, which is equivalent to g/mol aka molar mass)#
	# put another way - How much does one mole of base pairs weigh in grams? (650 for double stranded DNA [dsDNA])#
	mass_bp <- 650#
#
	# Avogadro's number#
	avo_num <- 6.022e23#
	# unit correction (use 1e9 for nanograms)#
	unit_correction <- 1e9#
	copies <- (mass_fragment * avo_num)/(length_fragment * unit_correction * mass_bp)#
	return(copies)#
}
num_copies(length_fragment = 200, mass_fragment = 10)
num_copies(length_fragment = 20, mass_fragment = 50)
num_copies(length_fragment = 670, mass_fragment = 150)
dnorm(10)
?dnorm
?dgamma
XX<-seq(0.001,10,length.out=1e5)
plot(dgamms(XX,0.01,0.01))
plot(dgamma(XX,0.01,0.01))
plot(dgamma(XX,0.01,0.01)~XX)
plot(dgamma(XX,0.01,0.01)~sqrt(XX))
plot(dgamma(XX,0.0001,0.0001)~sqrt(XX))
plot(dgamma(XX,0.000001,0.000001)~sqrt(XX))
p
P
counts <- as.matrix(read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/my_counts.csv", row.names = 1))
counts
library(R2jags)
taxa <- colnames(counts)
taxa
pcr <- rownames(counts)
pcr
N_taxa <- length(taxa)
N_taxa
N_pcr <- length(pcr)
N_pcr
model_loc <- c("jags_model_single_location.txt")
model_loc
jagsscript <- cat(#
"#
model {#
#
    ## MODEL STRUCTURE#
    for(i in 1:N_taxa){#
        for(j in 1:N_pcr){#
#
            # Likelihood function#
            counts[i,j] ~ dpois(exp(lambda[i,j]))#
#
            # GLM#
            lambda[i,j] <- beta_0 + beta[i] + eta[i,j]#
            # alt:#
            # fixed[i,j] <- beta_0 + beta[i]#
            # lambda[i,j] <- fixed[i] + eta[i,j]#
            # note that precision = 1/variance and variance = sd^2#
            # mu = mean, tau = precision#
            eta[i,j] ~ dnorm(mu = 0, tau = 1/sigma2)#
#
        }#
    }#
#
    ## PRIORS#
    # in JAGS gamma, shape = r and rate = mu (lambda?)#
    sigma2 ~ dgamma(r = 0.01, mu = 0.01)#
#
    # the general intercept (mean of counts of all taxa for all PCR replicates)#
    beta_0 ~ dnorm(mu = 0, tau = 1/1000)#
#
    # beta[1] must be zero, because for taxa[1]#
    beta[1] <- 0#
#
    for(i in 2:N_taxa){#
        # mu = mean, tau = precision#
        beta[i] ~ dnorm(mu = 0, tau = 1/1000)#
    }#
#
    ## DERIVED QUANTITIES#
    # i.e. estimated proportion of taxa[i]#
#
    # multinomial poisson transformation#
    for(i in 1:N_taxa){#
        p[i] <- exp(beta_0 + beta[i])#
    }#
#
    for(i in 1:N_taxa){#
        P[i] <- p[i] / sum(p)#
    }#
#
}#
",#
file = model_loc)
jags_data <- list(#
                "counts",#
                "N_taxa",#
                "N_pcr"#
)
jags_data
jags_params <- c(#
                "beta",#
                "sigma2",#
                "P",#
                "beta_0"#
)
N_burn <- 10#
#
N_iter <- 10#
#
N_chain <- 1
my_jags_model <- jags(#
					data = jags_data,#
					inits = NULL,#
					parameters.to.save = jags_params,#
					model.file = model_loc,#
					n.chains = N_chain,#
					n.iter = N_iter + N_burn,#
					n.burnin = N_burn, #floor(n.iter/2)#
					n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
					DIC = TRUE,#
					working.directory = NULL,#
					jags.seed = 123,#
					refresh = N_iter/50,#
					progress.bar = "text",#
					digits = 5,#
					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
					jags.module = c("glm","dic")#
)
jagsscript <- cat(#
"#
model {#
#
    ## MODEL STRUCTURE#
    for(i in 1:N_taxa){#
        for(j in 1:N_pcr){#
#
            # Likelihood function#
            counts[i,j] ~ dpois(exp(lambda[i,j]))#
#
            # GLM#
            lambda[i,j] <- beta_0 + beta[i] + eta[i,j]#
            # alt:#
            # fixed[i,j] <- beta_0 + beta[i]#
            # lambda[i,j] <- fixed[i] + eta[i,j]#
            # note that precision = 1/variance and variance = sd^2#
            # mu = mean, tau = precision#
            eta[i,j] ~ dnorm(0, 1/sigma2)#
#
        }#
    }#
#
    ## PRIORS#
    # in JAGS gamma, shape = r and rate = mu (lambda?)#
    sigma2 ~ dgamma(r = 0.01, mu = 0.01)#
#
    # the general intercept (mean of counts of all taxa for all PCR replicates)#
    beta_0 ~ dnorm(mu = 0, tau = 1/1000)#
#
    # beta[1] must be zero, because for taxa[1]#
    beta[1] <- 0#
#
    for(i in 2:N_taxa){#
        # mu = mean, tau = precision#
        beta[i] ~ dnorm(mu = 0, tau = 1/1000)#
    }#
#
    ## DERIVED QUANTITIES#
    # i.e. estimated proportion of taxa[i]#
#
    # multinomial poisson transformation#
    for(i in 1:N_taxa){#
        p[i] <- exp(beta_0 + beta[i])#
    }#
#
    for(i in 1:N_taxa){#
        P[i] <- p[i] / sum(p)#
    }#
#
}#
",#
file = model_loc)
my_jags_model <- jags(#
					data = jags_data,#
					inits = NULL,#
					parameters.to.save = jags_params,#
					model.file = model_loc,#
					n.chains = N_chain,#
					n.iter = N_iter + N_burn,#
					n.burnin = N_burn, #floor(n.iter/2)#
					n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
					DIC = TRUE,#
					working.directory = NULL,#
					jags.seed = 123,#
					refresh = N_iter/50,#
					progress.bar = "text",#
					digits = 5,#
					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
					jags.module = c("glm","dic")#
)
jagsscript <- cat(#
"#
model {#
#
    ## MODEL STRUCTURE#
    for(i in 1:N_taxa){#
        for(j in 1:N_pcr){#
#
            # Likelihood function#
            counts[i,j] ~ dpois(exp(lambda[i,j]))#
#
            # GLM#
            lambda[i,j] <- beta_0 + beta[i] + eta[i,j]#
            # alt:#
            # fixed[i,j] <- beta_0 + beta[i]#
            # lambda[i,j] <- fixed[i] + eta[i,j]#
            # note that precision = 1/variance and variance = sd^2#
            # mu = mean, tau = precision#
            eta[i,j] ~ dnorm(0, 1/sigma2)#
#
        }#
    }#
#
    ## PRIORS#
    # in JAGS gamma, shape = r and rate = mu (lambda?)#
    sigma2 ~ dgamma(0.01, 0.01)#
#
    # the general intercept (mean of counts of all taxa for all PCR replicates)#
    beta_0 ~ dnorm(0, 1/1000)#
#
    # beta[1] must be zero, because for taxa[1]#
    beta[1] <- 0#
#
    for(i in 2:N_taxa){#
        # mu = mean, tau = precision#
        beta[i] ~ dnorm(0, 1/1000)#
    }#
#
    ## DERIVED QUANTITIES#
    # i.e. estimated proportion of taxa[i]#
#
    # multinomial poisson transformation#
    for(i in 1:N_taxa){#
        p[i] <- exp(beta_0 + beta[i])#
    }#
#
    for(i in 1:N_taxa){#
        P[i] <- p[i] / sum(p)#
    }#
#
}#
",#
file = model_loc)
my_jags_model <- jags(#
					data = jags_data,#
					inits = NULL,#
					parameters.to.save = jags_params,#
					model.file = model_loc,#
					n.chains = N_chain,#
					n.iter = N_iter + N_burn,#
					n.burnin = N_burn, #floor(n.iter/2)#
					n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
					DIC = TRUE,#
					working.directory = NULL,#
					jags.seed = 123,#
					refresh = N_iter/50,#
					progress.bar = "text",#
					digits = 5,#
					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
					jags.module = c("glm","dic")#
)
N_taxa
N_pcr
strcounts
str(counts)
class(counts)
counts
jagsscript <- cat(#
"#
model {#
#
    ## MODEL STRUCTURE#
    for(j in 1:N_pcr){#
    	for(i in 1:N_taxa){#
#
            # Likelihood function#
            counts[i,j] ~ dpois(exp(lambda[i,j]))#
#
            # GLM#
            lambda[i,j] <- beta_0 + beta[i] + eta[i,j]#
            # alt:#
            # fixed[i,j] <- beta_0 + beta[i]#
            # lambda[i,j] <- fixed[i] + eta[i,j]#
            # note that precision = 1/variance and variance = sd^2#
            # mu = mean, tau = precision#
            eta[i,j] ~ dnorm(0, 1/sigma2)#
#
        }#
    }#
#
    ## PRIORS#
    # in JAGS gamma, shape = r and rate = mu (lambda?)#
    sigma2 ~ dgamma(0.01, 0.01)#
#
    # the general intercept (mean of counts of all taxa for all PCR replicates)#
    beta_0 ~ dnorm(0, 1/1000)#
#
    # beta[1] must be zero, because for taxa[1]#
    beta[1] <- 0#
#
    for(i in 2:N_taxa){#
        # mu = mean, tau = precision#
        beta[i] ~ dnorm(0, 1/1000)#
    }#
#
    ## DERIVED QUANTITIES#
    # i.e. estimated proportion of taxa[i]#
#
    # multinomial poisson transformation#
    for(i in 1:N_taxa){#
        p[i] <- exp(beta_0 + beta[i])#
    }#
#
    for(i in 1:N_taxa){#
        P[i] <- p[i] / sum(p)#
    }#
#
}#
",#
file = model_loc)
my_jags_model <- jags(#
					data = jags_data,#
					inits = NULL,#
					parameters.to.save = jags_params,#
					model.file = model_loc,#
					n.chains = N_chain,#
					n.iter = N_iter + N_burn,#
					n.burnin = N_burn, #floor(n.iter/2)#
					n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
					DIC = TRUE,#
					working.directory = NULL,#
					jags.seed = 123,#
					refresh = N_iter/50,#
					progress.bar = "text",#
					digits = 5,#
					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
					jags.module = c("glm","dic")#
)
counts <- t(counts)
counts
jagsscript <- cat(#
"#
model {#
#
    ## MODEL STRUCTURE#
    for(j in 1:N_pcr){#
    	for(i in 1:N_taxa){#
#
            # Likelihood function#
            counts[i,j] ~ dpois(exp(lambda[i,j]))#
#
            # GLM#
            lambda[i,j] <- beta_0 + beta[i] + eta[i,j]#
            # alt:#
            # fixed[i,j] <- beta_0 + beta[i]#
            # lambda[i,j] <- fixed[i] + eta[i,j]#
            # note that precision = 1/variance and variance = sd^2#
            # mu = mean, tau = precision#
            eta[i,j] ~ dnorm(0, 1/sigma2)#
#
        }#
    }#
#
    ## PRIORS#
    # in JAGS gamma, shape = r and rate = mu (lambda?)#
    sigma2 ~ dgamma(0.01, 0.01)#
#
    # the general intercept (mean of counts of all taxa for all PCR replicates)#
    beta_0 ~ dnorm(0, 1/1000)#
#
    # beta[1] must be zero, because for taxa[1]#
    beta[1] <- 0#
#
    for(i in 2:N_taxa){#
        # mu = mean, tau = precision#
        beta[i] ~ dnorm(0, 1/1000)#
    }#
#
    ## DERIVED QUANTITIES#
    # i.e. estimated proportion of taxa[i]#
#
    # multinomial poisson transformation#
    for(i in 1:N_taxa){#
        p[i] <- exp(beta_0 + beta[i])#
    }#
#
    for(i in 1:N_taxa){#
        P[i] <- p[i] / sum(p)#
    }#
#
}#
",#
file = model_loc)
my_jags_model <- jags(#
					data = jags_data,#
					inits = NULL,#
					parameters.to.save = jags_params,#
					model.file = model_loc,#
					n.chains = N_chain,#
					n.iter = N_iter + N_burn,#
					n.burnin = N_burn, #floor(n.iter/2)#
					n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
					DIC = TRUE,#
					working.directory = NULL,#
					jags.seed = 123,#
					refresh = N_iter/50,#
					progress.bar = "text",#
					digits = 5,#
					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
					jags.module = c("glm","dic")#
)
A<-my_jags_model
summary(A)
A$BUGSoutput$summary
#!/usr/bin/env Rscript#
#
library(R2jags)#
#
# This is code to estimate some model parameters for proportional abundance of DNA in a sample given reads in the file from a sequencer#
# Let:#
# i = taxon i (1:I); Carkeek grid dataset I = ? (limit to 10 for tests)#
# j = PCR replicate j (1:J); Carkeek grid dataset J = 4#
# k = location k (1:K); Carkeek grid dataset K = 24#
# Requires as input#
# counts of sequences (Z, length = ...)#
counts <- as.matrix(read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/my_counts.csv", row.names = 1))#
counts <- t(counts)#
#
# of each taxon (length = I)#
taxa <- rownames(counts)#
# from each PCR replicate (length = J)#
pcr <- colnames(counts)#
# at each site (length = K)#
# sites <-#
#
N_taxa <- length(taxa)#
N_pcr <- length(pcr)#
#
# lambda = mean of the Poisson dist that describes variation in counts#
# beta = intercept#
# eta = random effect for i,j,k#
# sigma2 = variance of normal distribution describing eta (attributable to PCR)#
#
# epsilon = random effect for i,k#
# tau2 = variance of normal distribution describing epsilon (attributable to location - k)#
#
# gamma =#
# phi#
#
# pi =#
#
model_loc <- c("jags_model_single_location.txt")#
jagsscript <- cat(#
"#
model {#
#
    ## MODEL STRUCTURE#
    for(j in 1:N_pcr){#
    	for(i in 1:N_taxa){#
#
            # Likelihood function#
            counts[i,j] ~ dpois(exp(lambda[i,j]))#
#
            # GLM#
            lambda[i,j] <- beta_0 + beta[i] + eta[i,j]#
            # alt:#
            # fixed[i,j] <- beta_0 + beta[i]#
            # lambda[i,j] <- fixed[i] + eta[i,j]#
            # note that precision = 1/variance and variance = sd^2#
            # mu = mean, tau = precision#
            eta[i,j] ~ dnorm(0, 1/sigma2)#
#
        }#
    }#
#
    ## PRIORS#
    # in JAGS gamma, shape = r and rate = mu (lambda?)#
    sigma2 ~ dgamma(0.01, 0.01)#
#
    # the general intercept (mean of counts of all taxa for all PCR replicates)#
    beta_0 ~ dnorm(0, 1/1000)#
#
    # beta[1] must be zero, because for taxa[1]#
    beta[1] <- 0#
#
    for(i in 2:N_taxa){#
        # mu = mean, tau = precision#
        beta[i] ~ dnorm(0, 1/1000)#
    }#
#
    ## DERIVED QUANTITIES#
    # i.e. estimated proportion of taxa[i]#
#
    # multinomial poisson transformation#
    for(i in 1:N_taxa){#
        p[i] <- exp(beta_0 + beta[i])#
    }#
#
    for(i in 1:N_taxa){#
        P[i] <- p[i] / sum(p)#
    }#
#
}#
",#
file = model_loc)#
jags_data <- list(#
                "counts",#
                "N_taxa",#
                "N_pcr"#
)#
#
jags_params <- c(#
                "beta",#
                "sigma2",#
                "P",#
                "beta_0"#
)#
N_burn <- 1000#
#
N_iter <- 1000#
#
N_chain <- 1#
#
my_jags_model <- jags(#
					data = jags_data,#
					inits = NULL,#
					parameters.to.save = jags_params,#
					model.file = model_loc,#
					n.chains = N_chain,#
					n.iter = N_iter + N_burn,#
					n.burnin = N_burn, #floor(n.iter/2)#
					n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
					DIC = TRUE,#
					working.directory = NULL,#
					jags.seed = 123,#
					refresh = N_iter/50,#
					progress.bar = "text",#
					digits = 5,#
					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
					jags.module = c("glm","dic")#
)#
#
attach.jags(my_jags_model, overwrite = TRUE)
A<-my_jags_model
A$BUGSoutput$summary
counts <- as.matrix(read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/grid_10otus.csv", row.names = 1))
counts
counts <- counts[,1:4]
counts
# of each taxon (length = I)#
taxa <- rownames(counts)#
# from each PCR replicate (length = J)#
pcr <- colnames(counts)#
# at each site (length = K)#
# sites <-#
#
N_taxa <- length(taxa)#
N_pcr <- length(pcr)
model_loc <- c("jags_model_single_location.txt")#
jagsscript <- cat(#
"#
model {#
#
    ## MODEL STRUCTURE#
    for(j in 1:N_pcr){#
    	for(i in 1:N_taxa){#
#
            # Likelihood function#
            counts[i,j] ~ dpois(exp(lambda[i,j]))#
#
            # GLM#
            lambda[i,j] <- beta_0 + beta[i] + eta[i,j]#
            # alt:#
            # fixed[i,j] <- beta_0 + beta[i]#
            # lambda[i,j] <- fixed[i] + eta[i,j]#
            # note that precision = 1/variance and variance = sd^2#
            # mu = mean, tau = precision#
            eta[i,j] ~ dnorm(0, 1/sigma2)#
#
        }#
    }#
#
    ## PRIORS#
    # in JAGS gamma, shape = r and rate = mu (lambda?)#
    sigma2 ~ dgamma(0.01, 0.01)#
#
    # the general intercept (mean of counts of all taxa for all PCR replicates)#
    beta_0 ~ dnorm(0, 1/1000)#
#
    # beta[1] must be zero, because for taxa[1]#
    beta[1] <- 0#
#
    for(i in 2:N_taxa){#
        # mu = mean, tau = precision#
        beta[i] ~ dnorm(0, 1/1000)#
    }#
#
    ## DERIVED QUANTITIES#
    # i.e. estimated proportion of taxa[i]#
#
    # multinomial poisson transformation#
    for(i in 1:N_taxa){#
        p[i] <- exp(beta_0 + beta[i])#
    }#
#
    for(i in 1:N_taxa){#
        P[i] <- p[i] / sum(p)#
    }#
#
}#
",#
file = model_loc)
jags_data <- list(#
                "counts",#
                "N_taxa",#
                "N_pcr"#
)#
#
jags_params <- c(#
                "beta",#
                "sigma2",#
                "P",#
                "beta_0"#
)#
N_burn <- 1000#
#
N_iter <- 1000#
#
N_chain <- 1#
#
my_jags <- jags(#
				data = jags_data,#
				inits = NULL,#
				parameters.to.save = jags_params,#
				model.file = model_loc,#
				n.chains = N_chain,#
				n.iter = N_iter + N_burn,#
				n.burnin = N_burn, #floor(n.iter/2)#
				n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
				DIC = TRUE,#
				working.directory = NULL,#
				jags.seed = 123,#
				refresh = N_iter/50,#
				progress.bar = "text",#
				digits = 5,					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
				jags.module = c("glm","dic")#
)
my_jags
my_jags$BUGSoutput$summary
sqrt(3.04)
sqrt(0.03)
exp(1.15+0.17)
exp(1.15-0.17)
N_burn <- 1000#
#
N_iter <- 1000#
#
N_chain <- 3#
#
my_jags <- jags(#
				data = jags_data,#
				inits = NULL,#
				parameters.to.save = jags_params,#
				model.file = model_loc,#
				n.chains = N_chain,#
				n.iter = N_iter + N_burn,#
				n.burnin = N_burn, #floor(n.iter/2)#
				n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
				DIC = TRUE,#
				working.directory = NULL,#
				jags.seed = 123,#
				refresh = N_iter/50,#
				progress.bar = "text",#
				digits = 5,					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
				jags.module = c("glm","dic")#
)#
#
attach.jags(my_jags, overwrite = TRUE)
my_jags$BUGSoutput$summary
#!/usr/bin/env Rscript#
#
library(R2jags)#
#
# This is code to estimate some model parameters for proportional abundance of DNA in a sample given reads in the file from a sequencer#
# Let:#
# i = taxon i (1:I); Carkeek grid dataset I = ? (limit to 10 for tests)#
# j = PCR replicate j (1:J); Carkeek grid dataset J = 4#
# k = location k (1:K); Carkeek grid dataset K = 24#
# Requires as input#
# counts of sequences (Z, length = ...)#
counts <- as.matrix(read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/grid_10otus.csv", row.names = 1))#
#
# counts <- t(counts)#
counts <- counts[,1:4]#
#
# of each taxon (length = I)#
taxa <- rownames(counts)#
# from each PCR replicate (length = J)#
pcr <- colnames(counts)#
# at each site (length = K)#
# sites <-#
#
N_taxa <- length(taxa)#
N_pcr <- length(pcr)#
#
# lambda = mean of the Poisson dist that describes variation in counts#
# beta = intercept#
# eta = random effect for i,j,k#
# sigma2 = variance of normal distribution describing eta (attributable to PCR)#
#
# epsilon = random effect for i,k#
# tau2 = variance of normal distribution describing epsilon (attributable to location - k)#
#
# gamma =#
# phi#
#
# pi =#
#
model_loc <- c("jags_model_single_location.txt")#
jagsscript <- cat(#
"#
model {#
#
    ## MODEL STRUCTURE#
    for(j in 1:N_pcr){#
    	for(i in 1:N_taxa){#
#
            # Likelihood function#
            counts[i,j] ~ dpois(exp(lambda[i,j]))#
#
            # GLM#
            lambda[i,j] <- beta_0 + beta[i] + eta[i,j]#
            # alt:#
            # fixed[i,j] <- beta_0 + beta[i]#
            # lambda[i,j] <- fixed[i] + eta[i,j]#
            # note that precision = 1/variance and variance = sd^2#
            # mu = mean, tau = precision#
            eta[i,j] ~ dnorm(0, 1/sigma2[i])#
#
        }#
    }#
#
    ## PRIORS#
    # in JAGS gamma, shape = r and rate = mu (lambda?)#
    for(i in 1:N_taxa)#
    		sigma2[i] ~ dgamma(0.01, 0.01)#
	}#
    # the general intercept (mean of counts of all taxa for all PCR replicates)#
    beta_0 ~ dnorm(0, 1/1000)#
#
    # beta[1] must be zero, because for taxa[1]#
    beta[1] <- 0#
#
    for(i in 2:N_taxa){#
        # mu = mean, tau = precision#
        beta[i] ~ dnorm(0, 1/1000)#
    }#
#
    ## DERIVED QUANTITIES#
    # i.e. estimated proportion of taxa[i]#
#
    # multinomial poisson transformation#
    for(i in 1:N_taxa){#
        p[i] <- exp(beta_0 + beta[i])#
    }#
#
    for(i in 1:N_taxa){#
        P[i] <- p[i] / sum(p)#
    }#
#
}#
",#
file = model_loc)#
jags_data <- list(#
                "counts",#
                "N_taxa",#
                "N_pcr"#
)#
#
jags_params <- c(#
                "beta",#
                "sigma2",#
                "P",#
                "beta_0"#
)#
N_burn <- 1000#
#
N_iter <- 1000#
#
N_chain <- 3#
#
my_jags <- jags(#
				data = jags_data,#
				inits = NULL,#
				parameters.to.save = jags_params,#
				model.file = model_loc,#
				n.chains = N_chain,#
				n.iter = N_iter + N_burn,#
				n.burnin = N_burn, #floor(n.iter/2)#
				n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
				DIC = TRUE,#
				working.directory = NULL,#
				jags.seed = 123,#
				refresh = N_iter/50,#
				progress.bar = "text",#
				digits = 5,					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
				jags.module = c("glm","dic")#
)#
#
attach.jags(my_jags, overwrite = TRUE)
#!/usr/bin/env Rscript#
#
library(R2jags)#
#
# This is code to estimate some model parameters for proportional abundance of DNA in a sample given reads in the file from a sequencer#
# Let:#
# i = taxon i (1:I); Carkeek grid dataset I = ? (limit to 10 for tests)#
# j = PCR replicate j (1:J); Carkeek grid dataset J = 4#
# k = location k (1:K); Carkeek grid dataset K = 24#
# Requires as input#
# counts of sequences (Z, length = ...)#
counts <- as.matrix(read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/grid_10otus.csv", row.names = 1))#
#
# counts <- t(counts)#
counts <- counts[,1:4]#
#
# of each taxon (length = I)#
taxa <- rownames(counts)#
# from each PCR replicate (length = J)#
pcr <- colnames(counts)#
# at each site (length = K)#
# sites <-#
#
N_taxa <- length(taxa)#
N_pcr <- length(pcr)#
#
# lambda = mean of the Poisson dist that describes variation in counts#
# beta = intercept#
# eta = random effect for i,j,k#
# sigma2 = variance of normal distribution describing eta (attributable to PCR)#
#
# epsilon = random effect for i,k#
# tau2 = variance of normal distribution describing epsilon (attributable to location - k)#
#
# gamma =#
# phi#
#
# pi =#
#
model_loc <- c("jags_model_single_location.txt")#
jagsscript <- cat(#
"#
model {#
#
    ## MODEL STRUCTURE#
    for(j in 1:N_pcr){#
    	for(i in 1:N_taxa){#
#
            # Likelihood function#
            counts[i,j] ~ dpois(exp(lambda[i,j]))#
#
            # GLM#
            lambda[i,j] <- beta_0 + beta[i] + eta[i,j]#
            # alt:#
            # fixed[i,j] <- beta_0 + beta[i]#
            # lambda[i,j] <- fixed[i] + eta[i,j]#
            # note that precision = 1/variance and variance = sd^2#
            # mu = mean, tau = precision#
            eta[i,j] ~ dnorm(0, 1/sigma2[i])#
#
        }#
    }#
#
    ## PRIORS#
    # in JAGS gamma, shape = r and rate = mu (lambda?)#
    for(i in 1:N_taxa){#
    		sigma2[i] ~ dgamma(0.01, 0.01)#
	}#
    # the general intercept (mean of counts of all taxa for all PCR replicates)#
    beta_0 ~ dnorm(0, 1/1000)#
#
    # beta[1] must be zero, because for taxa[1]#
    beta[1] <- 0#
#
    for(i in 2:N_taxa){#
        # mu = mean, tau = precision#
        beta[i] ~ dnorm(0, 1/1000)#
    }#
#
    ## DERIVED QUANTITIES#
    # i.e. estimated proportion of taxa[i]#
#
    # multinomial poisson transformation#
    for(i in 1:N_taxa){#
        p[i] <- exp(beta_0 + beta[i])#
    }#
#
    for(i in 1:N_taxa){#
        P[i] <- p[i] / sum(p)#
    }#
#
}#
",#
file = model_loc)#
jags_data <- list(#
                "counts",#
                "N_taxa",#
                "N_pcr"#
)#
#
jags_params <- c(#
                "beta",#
                "sigma2",#
                "P",#
                "beta_0"#
)#
N_burn <- 1000#
#
N_iter <- 1000#
#
N_chain <- 3#
#
my_jags <- jags(#
				data = jags_data,#
				inits = NULL,#
				parameters.to.save = jags_params,#
				model.file = model_loc,#
				n.chains = N_chain,#
				n.iter = N_iter + N_burn,#
				n.burnin = N_burn, #floor(n.iter/2)#
				n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
				DIC = TRUE,#
				working.directory = NULL,#
				jags.seed = 123,#
				refresh = N_iter/50,#
				progress.bar = "text",#
				digits = 5,					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
				jags.module = c("glm","dic")#
)#
#
attach.jags(my_jags, overwrite = TRUE)
my_jags$BUGSoutput$summary
#!/usr/bin/env Rscript#
#
library(R2jags)#
#
# This is code to estimate some model parameters for proportional abundance of DNA in a sample given reads in the file from a sequencer#
# Let:#
# i = taxon i (1:I); Carkeek grid dataset I = ? (limit to 10 for tests)#
# j = PCR replicate j (1:J); Carkeek grid dataset J = 4#
# k = location k (1:K); Carkeek grid dataset K = 24#
# Requires as input#
# counts of sequences (Z, length = ...)#
counts <- as.matrix(read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/grid_10otus.csv", row.names = 1))#
#
# counts <- t(counts)#
counts <- counts[,1:4]#
#
# of each taxon (length = I)#
taxa <- rownames(counts)#
# from each PCR replicate (length = J)#
pcr <- colnames(counts)#
# at each site (length = K)#
# sites <-#
#
N_taxa <- length(taxa)#
N_pcr <- length(pcr)#
#
# lambda = mean of the Poisson dist that describes variation in counts#
# beta = intercept#
# eta = random effect for i,j,k#
# sigma2 = variance of normal distribution describing eta (attributable to PCR)#
#
# epsilon = random effect for i,k#
# tau2 = variance of normal distribution describing epsilon (attributable to location - k)#
#
# gamma =#
# phi#
#
# pi =#
#
model_loc <- c("jags_model_single_location.txt")#
jagsscript <- cat(#
# "#
model {#
#
    ## MODEL STRUCTURE#
    for(j in 1:N_pcr){#
    	for(i in 1:N_taxa){#
#
            # Likelihood function#
            counts[i,j] ~ dpois(exp(lambda[i,j]))#
#
            # GLM#
            lambda[i,j] <- beta_0 + beta[i] + eta[i,j]#
            # alt:#
            # fixed[i,j] <- beta_0 + beta[i]#
            # lambda[i,j] <- fixed[i] + eta[i,j]#
            # note that precision = 1/variance and variance = sd^2#
            # mu = mean, tau = precision#
            eta[i,j] ~ dnorm(0, 1/sigma2)#
#
        }#
    }#
#
    ## PRIORS#
    # to allow variance attributable to PCR to vary among species#
    # for(i in 1:N_taxa){#
	    # in JAGS gamma, shape = r and rate = mu (lambda?)#
    	sigma2 ~ dgamma(0.01, 0.01)#
	# }#
    # the general intercept (mean of counts of all taxa for all PCR replicates)#
    beta_0 ~ dnorm(0, 1/1000)#
#
    # beta[1] must be zero, because for taxa[1]#
    beta[1] <- 0#
#
    for(i in 2:N_taxa){#
        # mu = mean, tau = precision#
        beta[i] ~ dnorm(0, 1/1000)#
    }#
#
    ## DERIVED QUANTITIES#
    # i.e. estimated proportion of taxa[i]#
#
    # multinomial poisson transformation#
    for(i in 1:N_taxa){#
        p[i] <- exp(beta_0 + beta[i])#
    }#
#
    for(i in 1:N_taxa){#
        P[i] <- p[i] / sum(p)#
    }#
#
}#
# ",#
file = model_loc)#
jags_data <- list(#
                "counts",#
                "N_taxa",#
                "N_pcr"#
)#
#
jags_params <- c(#
                "beta",#
                "sigma2",#
                "P",#
                "beta_0"#
)#
N_burn <- 1000#
#
N_iter <- 1000#
#
N_chain <- 3#
#
my_jags <- jags(#
				data = jags_data,#
				inits = NULL,#
				parameters.to.save = jags_params,#
				model.file = model_loc,#
				n.chains = N_chain,#
				n.iter = N_iter + N_burn,#
				n.burnin = N_burn, #floor(n.iter/2)#
				n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
				DIC = TRUE,#
				working.directory = NULL,#
				jags.seed = 123,#
				refresh = N_iter/50,#
				progress.bar = "text",#
				digits = 5,					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
				jags.module = c("glm","dic")#
)#
#
attach.jags(my_jags, overwrite = TRUE)
#!/usr/bin/env Rscript#
#
library(R2jags)#
#
# This is code to estimate some model parameters for proportional abundance of DNA in a sample given reads in the file from a sequencer#
# Let:#
# i = taxon i (1:I); Carkeek grid dataset I = ? (limit to 10 for tests)#
# j = PCR replicate j (1:J); Carkeek grid dataset J = 4#
# k = location k (1:K); Carkeek grid dataset K = 24#
# Requires as input#
# counts of sequences (Z, length = ...)#
counts <- as.matrix(read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/grid_10otus.csv", row.names = 1))#
#
# counts <- t(counts)#
counts <- counts[,1:4]#
#
# of each taxon (length = I)#
taxa <- rownames(counts)#
# from each PCR replicate (length = J)#
pcr <- colnames(counts)#
# at each site (length = K)#
# sites <-#
#
N_taxa <- length(taxa)#
N_pcr <- length(pcr)#
#
# lambda = mean of the Poisson dist that describes variation in counts#
# beta = intercept#
# eta = random effect for i,j,k#
# sigma2 = variance of normal distribution describing eta (attributable to PCR)#
#
# epsilon = random effect for i,k#
# tau2 = variance of normal distribution describing epsilon (attributable to location - k)#
#
# gamma =#
# phi#
#
# pi =#
#
model_loc <- c("jags_model_single_location.txt")#
jagsscript <- cat(#
"#
model {#
#
    ## MODEL STRUCTURE#
    for(j in 1:N_pcr){#
    	for(i in 1:N_taxa){#
#
            # Likelihood function#
            counts[i,j] ~ dpois(exp(lambda[i,j]))#
#
            # GLM#
            lambda[i,j] <- beta_0 + beta[i] + eta[i,j]#
            # alt:#
            # fixed[i,j] <- beta_0 + beta[i]#
            # lambda[i,j] <- fixed[i] + eta[i,j]#
            # note that precision = 1/variance and variance = sd^2#
            # mu = mean, tau = precision#
            eta[i,j] ~ dnorm(0, 1/sigma2)#
#
        }#
    }#
#
    ## PRIORS#
    # to allow variance attributable to PCR to vary among species#
    # for(i in 1:N_taxa){#
	    # in JAGS gamma, shape = r and rate = mu (lambda?)#
    	sigma2 ~ dgamma(0.01, 0.01)#
	# }#
    # the general intercept (mean of counts of all taxa for all PCR replicates)#
    beta_0 ~ dnorm(0, 1/1000)#
#
    # beta[1] must be zero, because for taxa[1]#
    beta[1] <- 0#
#
    for(i in 2:N_taxa){#
        # mu = mean, tau = precision#
        beta[i] ~ dnorm(0, 1/1000)#
    }#
#
    ## DERIVED QUANTITIES#
    # i.e. estimated proportion of taxa[i]#
#
    # multinomial poisson transformation#
    for(i in 1:N_taxa){#
        p[i] <- exp(beta_0 + beta[i])#
    }#
#
    for(i in 1:N_taxa){#
        P[i] <- p[i] / sum(p)#
    }#
#
}#
",#
file = model_loc)#
jags_data <- list(#
                "counts",#
                "N_taxa",#
                "N_pcr"#
)#
#
jags_params <- c(#
                "beta",#
                "sigma2",#
                "P",#
                "beta_0"#
)#
N_burn <- 1000#
#
N_iter <- 1000#
#
N_chain <- 3#
#
my_jags <- jags(#
				data = jags_data,#
				inits = NULL,#
				parameters.to.save = jags_params,#
				model.file = model_loc,#
				n.chains = N_chain,#
				n.iter = N_iter + N_burn,#
				n.burnin = N_burn, #floor(n.iter/2)#
				n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
				DIC = TRUE,#
				working.directory = NULL,#
				jags.seed = 123,#
				refresh = N_iter/50,#
				progress.bar = "text",#
				digits = 5,					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
				jags.module = c("glm","dic")#
)#
#
attach.jags(my_jags, overwrite = TRUE)
counts <- as.matrix(read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/grid_10otus.csv", row.names = 1))
counts <- counts[,1:12]
4378*12
plot(Sepal.Length ~ Petal.Length,#
      xlab = "Petal Length (cm)",#
      ylab = "Sepal Length (cm)",#
      pch = c(16, 17, 18)[as.numeric(Species)],  # different 'pch' types #
      main = "Anderson Iris Dataset",#
      col = c("red", "green","blue")[as.numeric(Species)],#
      data = iris)
library(R2jags)
counts_table <- read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/OTUs_top10_4000m.csv", row.names = 1)
metadata <- read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/metadata_spatial.csv", stringsAsFactors = FALSE)
colname_sampleid <- "sample_id"
colname_pcr <- "PCR_replicate"
colname_site <- "transect"
taxa <- colnames(counts_table)
counts_table
pcr <- unique(metadata[, colname_pcr])
# at each site (length = K)
sites <- unique(metadata[, colname_site])
sites
pcr
taxa
N_taxa <- length(taxa)#
N_pcr <- length(pcr)#
N_sites <- length(sites)
site_by_rowname <- metadata[ , colname_site][#
  match(rownames(counts_table), metadata[ , colname_sampleid])#
  ]
site_by_rowname
counts_by_site <- split(x = counts_table, f = site_by_rowname)
counts_by_site
counts <- array(#
  data = unlist(counts_by_site), #
  dim = c(length(pcr), length(taxa), length(sites)), #
  dimnames = list(#
    pcr = pcr, #
    taxa = taxa, #
    sites = sites#
  )#
)
counts[        ,         , sites[2] ]
counts[ pcr[4] ,         ,          ]
counts[        , taxa[8] ,          ]
counts_table
counts
counts_table
model_loc <- c("jags_model_multi_location.txt")
jagsscript <- cat(#
  "#
  model {#
  ## MODEL STRUCTURE#
  for(j in 1:N_pcr){#
  for(i in 1:N_taxa){#
  # Likelihood function#
  counts[i,j] ~ dpois(exp(lambda[i,j]))#
  # GLM#
  lambda[i,j] <- beta_0 + beta[i] + eta[i,j]#
  # alt:#
  # fixed[i,j] <- beta_0 + beta[i]#
  # lambda[i,j] <- fixed[i] + eta[i,j]#
  # note that precision = 1/variance and variance = sd^2#
  # mu = mean, tau = precision#
  eta[i,j] ~ dnorm(0, 1/sigma2)#
  }#
  }#
  ## PRIORS#
  # to allow variance attributable to PCR to vary among species#
  # for(i in 1:N_taxa){#
  # in JAGS gamma, shape = r and rate = mu (lambda?)#
  sigma2 ~ dgamma(0.01, 0.01)#
  # }#
  # the general intercept (mean of counts of all taxa for all PCR replicates)#
  beta_0 ~ dnorm(0, 1/1000)#
  # beta[1] must be zero, because for taxa[1]#
  beta[1] <- 0#
  for(i in 2:N_taxa){#
  # mu = mean, tau = precision#
  beta[i] ~ dnorm(0, 1/1000)#
  }#
  ## DERIVED QUANTITIES#
  # i.e. estimated proportion of taxa[i]#
  # multinomial poisson transformation#
  for(i in 1:N_taxa){#
  p[i] <- exp(beta_0 + beta[i])#
  }#
  for(i in 1:N_taxa){#
  P[i] <- p[i] / sum(p)#
  }#
  }#
  ",#
  file = model_loc)#
jags_data <- list(#
  "counts",#
  "N_taxa",#
  "N_pcr"#
)
jags_params <- c(#
  "beta",#
  "sigma2",#
  "P",#
  "beta_0"#
)
N_burn <- 1000#
#
N_iter <- 1000#
#
N_chain <- 3
var1
var1 <- "cats"
var2 <- "dogs"
c(var1, var2)
identical(c(var1, var2), c("cats", "dogs"))
model
model_loc
jagsscript
jagsscript <- cat(#
  "#
  model {#
  ## MODEL STRUCTURE#
  for(j in 1:N_pcr){#
  for(i in 1:N_taxa){#
  # Likelihood function#
  counts[i,j] ~ dpois(exp(lambda[i,j]))#
  # GLM#
  lambda[i,j] <- beta_0 + beta[i] + eta[i,j]#
  # alt:#
  # fixed[i,j] <- beta_0 + beta[i]#
  # lambda[i,j] <- fixed[i] + eta[i,j]#
  # note that precision = 1/variance and variance = sd^2#
  # mu = mean, tau = precision#
  eta[i,j] ~ dnorm(0, 1/sigma2)#
  }#
  }#
  ## PRIORS#
  # to allow variance attributable to PCR to vary among species#
  # for(i in 1:N_taxa){#
  # in JAGS gamma, shape = r and rate = mu (lambda?)#
  sigma2 ~ dgamma(0.01, 0.01)#
  # }#
  # the general intercept (mean of counts of all taxa for all PCR replicates)#
  beta_0 ~ dnorm(0, 1/1000)#
  # beta[1] must be zero, because for taxa[1]#
  beta[1] <- 0#
  for(i in 2:N_taxa){#
  # mu = mean, tau = precision#
  beta[i] ~ dnorm(0, 1/1000)#
  }#
  ## DERIVED QUANTITIES#
  # i.e. estimated proportion of taxa[i]#
  # multinomial poisson transformation#
  for(i in 1:N_taxa){#
  p[i] <- exp(beta_0 + beta[i])#
  }#
  for(i in 1:N_taxa){#
  P[i] <- p[i] / sum(p)#
  }#
  }#
  ",#
  file = model_loc)
jags_data <- list(#
  "counts",#
  "N_taxa",#
  "N_pcr"#
)
jags_params <- c(#
  "beta",#
  "sigma2",#
  "P",#
  "beta_0"#
)
N_burn <- 1000
N_iter <- 1000#
#
N_chain <- 3
jagsscript
my_jags
my_jags <- jags(#
  data = jags_data,#
  inits = NULL,#
  parameters.to.save = jags_params,#
  model.file = model_loc,#
  n.chains = N_chain,#
  n.iter = N_iter + N_burn,#
  n.burnin = N_burn, #floor(n.iter/2)#
  n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
  DIC = TRUE,#
  working.directory = NULL,#
  jags.seed = 123,#
  refresh = N_iter/50,#
  progress.bar = "text",#
  digits = 5,					RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
  jags.module = c("glm","dic")#
)
jagsscript
N_sites
epsilon
N_sites
jagsscript <- cat(#
  "#
  model {#
#
  ## MODEL STRUCTURE#
  for(k in 1:N_sites){#
    for(i in 1:N_taxa){#
      for(j in 1:N_pcr){#
#
      # Likelihood function#
      counts[j,i,k] ~ dpois(exp(lambda[j,i,k]))#
#
      # GLM#
      lambda[j,i,k] <- beta_0 + beta[i] + eta[j,i,k] + epsilon[j,i,k]#
      # alt:#
      # fixed[i,j] <- beta_0 + beta[i]#
      # lambda[i,j] <- fixed[i] + eta[i,j]#
#
      # note that precision = 1/variance and variance = sd^2#
      # mu = mean, tau = precision#
      eta[j,i,k] ~ dnorm(0, 1/sigma2)#
#
      epsilson[j,i,k] ~ dnorm(0, 1/tau2)#
#
      }#
    }#
  }#
#
  ## PRIORS#
#
  # the general intercept (mean of counts of all taxa for all PCR replicates)#
  beta_0 ~ dnorm(0, 1/1000)#
#
  # beta[1] must be zero, because for taxa[1]#
  beta[1] <- 0#
#
  for(i in 2:N_taxa){#
  # mu = mean, tau = precision#
  beta[i] ~ dnorm(0, 1/1000)#
  }#
#
  # to allow variance attributable to PCR to vary among species#
  # for(i in 1:N_taxa){#
  # in JAGS gamma, shape = r and rate = mu (lambda?)#
  sigma2 ~ dgamma(0.01, 0.01)#
  # }#
#
  tau2 ~ dgamma(0.01, 0.01)#
#
  ## DERIVED QUANTITIES#
  # i.e. estimated proportion of taxa[i]#
#
  # multinomial poisson transformation#
  for(i in 1:N_taxa){#
    p[i] <- exp(beta_0 + beta[i])#
  }#
#
  for(i in 1:N_taxa){#
    P[i] <- p[i] / sum(p)#
  }#
#
  }#
  ",#
  file = model_loc)
jags_data <- list(#
  "counts",#
  "N_taxa",#
  "N_pcr"#
)#
#
jags_params <- c(#
  "beta",#
  "sigma2",#
  "tau2"#
  "P",#
  "beta_0"#
)#
N_burn <- 1000#
#
N_iter <- 1000#
#
N_chain <- 3#
#
my_jags <- jags(#
  data = jags_data,#
  inits = NULL,#
  parameters.to.save = jags_params,#
  model.file = model_loc,#
  n.chains = N_chain,#
  n.iter = N_iter + N_burn,#
  n.burnin = N_burn, #floor(n.iter/2)#
  n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
  DIC = TRUE,#
  working.directory = NULL,#
  jags.seed = 123,#
  refresh = N_iter/50,#
  progress.bar = "text",#
  digits = 5,#
  RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
  jags.module = c("glm","dic")#
)
getwd()
file = model_loc)
jagsscript <- "#
  model {#
#
  ## MODEL STRUCTURE#
  for(k in 1:N_sites){#
    for(i in 1:N_taxa){#
      for(j in 1:N_pcr){#
#
      # Likelihood function#
      counts[j,i,k] ~ dpois(exp(lambda[j,i,k]))#
#
      # GLM#
      lambda[j,i,k] <- beta_0 + beta[i] + eta[j,i,k] + epsilon[j,i,k]#
      # alt:#
      # fixed[i,j] <- beta_0 + beta[i]#
      # lambda[i,j] <- fixed[i] + eta[i,j]#
#
      # note that precision = 1/variance and variance = sd^2#
      # mu = mean, tau = precision#
      eta[j,i,k] ~ dnorm(0, 1/sigma2)#
#
      epsilson[j,i,k] ~ dnorm(0, 1/tau2)#
#
      }#
    }#
  }#
#
  ## PRIORS#
#
  # the general intercept (mean of counts of all taxa for all PCR replicates)#
  beta_0 ~ dnorm(0, 1/1000)#
#
  # beta[1] must be zero, because for taxa[1]#
  beta[1] <- 0#
#
  for(i in 2:N_taxa){#
  # mu = mean, tau = precision#
  beta[i] ~ dnorm(0, 1/1000)#
  }#
#
  # to allow variance attributable to PCR to vary among species#
  # for(i in 1:N_taxa){#
  # in JAGS gamma, shape = r and rate = mu (lambda?)#
  sigma2 ~ dgamma(0.01, 0.01)#
  # }#
#
  tau2 ~ dgamma(0.01, 0.01)#
#
  ## DERIVED QUANTITIES#
  # i.e. estimated proportion of taxa[i]#
#
  # multinomial poisson transformation#
  for(i in 1:N_taxa){#
    p[i] <- exp(beta_0 + beta[i])#
  }#
#
  for(i in 1:N_taxa){#
    P[i] <- p[i] / sum(p)#
  }#
#
  }#
"
#!/usr/bin/env Rscript#
#
library(R2jags)#
#
# This is code to estimate some model parameters for proportional abundance of DNA in a sample given reads in the file from a sequencer#
# Let:#
# i = taxon i (1:I); Carkeek grid dataset I = ? (limit to 10 for tests)#
# j = PCR replicate j (1:J); Carkeek grid dataset J = 4#
# k = location k (1:K); Carkeek grid dataset K = 24#
# Requires as input:#
# 1. otu file#
# 2. metadata file#
#
# a table of counts of sequences (Z, length = ...)#
counts_table <- read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/OTUs_top10_4000m.csv", row.names = 1)#
# rows/rownames = samples, columns/colnames = taxa, cells = integer counts#
# if table is incorrectly oriented, transpose it:#
# counts_table <- as.data.frame(t(counts_table))#
#
# load metadata#
metadata <- read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/metadata_spatial.csv", stringsAsFactors = FALSE)#
#
# what is the name of the column containing the sample id (SEQUENCING samples)#
colname_sampleid <- "sample_id"#
#
# what is the name of the column containing PCR replicate levels#
colname_pcr <- "PCR_replicate"#
#
# what is the name of the column containing relevant site replicate levels#
colname_site <- "transect"#
#
# of each taxon (length = I)#
taxa <- colnames(counts_table)#
#
# from each PCR replicate (length = J)#
pcr <- unique(metadata[, colname_pcr])#
#
# at each site (length = K)#
sites <- unique(metadata[, colname_site])#
# JAGS won't do some basic R functions, so we need to give it the lengths explicitly#
N_taxa <- length(taxa)#
N_pcr <- length(pcr)#
N_sites <- length(sites)#
# make a vector of the site for each sample name in the counts table#
site_by_rowname <- metadata[ , colname_site][#
  match(rownames(counts_table), metadata[ , colname_sampleid])#
  ]#
#
# unused for now#
# sampleid_by_site <- split(x = metadata[, colname_sampleid], f = metadata[, colname_site], drop = TRUE)#
#
counts_by_site <- split(x = counts_table, f = site_by_rowname)#
# create an array for JAGS called "counts"#
# where counts[j,i,k] is the counts in pcr replicate j of taxon i at site k#
counts <- array(#
  data = unlist(counts_by_site),#
  dim = c(length(pcr), length(taxa), length(sites)),#
  dimnames = list(#
    pcr = pcr,#
    taxa = taxa,#
    sites = sites#
  )#
)#
#
# this really should be a function like this...#
# JAGSarray3D <- function(table, split_vector){#
##
# }#
#
# thus, you should be able to reference stuff like so:#
counts[ pcr[4] ,         ,          ]#
counts[        , taxa[8] ,          ]#
counts[        ,         , sites[2] ]#
#
# lambda = mean of the Poisson dist that describes variation in counts#
# beta = intercept#
# eta = random effect for i,j,k#
# sigma2 = variance of normal distribution describing eta (attributable to PCR)#
#
# epsilon = random effect for i,k#
# tau2 = variance of normal distribution describing epsilon (attributable to location - k)#
#
# gamma = coefficient of something, I think -- maybe the covariate matrix?#
# phi =#
#
# pi = proportional abundance of each taxon#
#
# counts <- counts_table#
#
model_loc <- c("jags_model_multi_location.txt")#
#
jags.model()#
jagsscript <- cat(#
"#
  model {#
#
  ## MODEL STRUCTURE#
  for(k in 1:N_sites){#
    for(i in 1:N_taxa){#
      for(j in 1:N_pcr){#
#
      # Likelihood function#
      counts[j,i,k] ~ dpois(exp(lambda[j,i,k]))#
#
      # GLM#
      lambda[j,i,k] <- beta_0 + beta[i] + eta[j,i,k] + epsilon[j,i,k]#
      # alt:#
      # fixed[i,j] <- beta_0 + beta[i]#
      # lambda[i,j] <- fixed[i] + eta[i,j]#
#
      # note that precision = 1/variance and variance = sd^2#
      # mu = mean, tau = precision#
      eta[j,i,k] ~ dnorm(0, 1/sigma2)#
#
      epsilson[j,i,k] ~ dnorm(0, 1/tau2)#
#
      }#
    }#
  }#
#
  ## PRIORS#
#
  # the general intercept (mean of counts of all taxa for all PCR replicates)#
  beta_0 ~ dnorm(0, 1/1000)#
#
  # beta[1] must be zero, because for taxa[1]#
  beta[1] <- 0#
#
  for(i in 2:N_taxa){#
  # mu = mean, tau = precision#
  beta[i] ~ dnorm(0, 1/1000)#
  }#
#
  # to allow variance attributable to PCR to vary among species#
  # for(i in 1:N_taxa){#
  # in JAGS gamma, shape = r and rate = mu (lambda?)#
  sigma2 ~ dgamma(0.01, 0.01)#
  # }#
#
  tau2 ~ dgamma(0.01, 0.01)#
#
  ## DERIVED QUANTITIES#
  # i.e. estimated proportion of taxa[i]#
#
  # multinomial poisson transformation#
  for(i in 1:N_taxa){#
    p[i] <- exp(beta_0 + beta[i])#
  }#
#
  for(i in 1:N_taxa){#
    P[i] <- p[i] / sum(p)#
  }#
#
  }#
  ",#
  file = model_loc#
)#
jags_data <- list(#
  "counts",#
  "N_taxa",#
  "N_pcr"#
)#
#
jags_params <- c(#
  "beta",#
  "sigma2",#
  "tau2"#
  "P",#
  "beta_0"#
)#
N_burn <- 1000#
#
N_iter <- 1000#
#
N_chain <- 3#
#
my_jags <- jags(#
  data = jags_data,#
  inits = NULL,#
  parameters.to.save = jags_params,#
  model.file = model_loc,#
  n.chains = N_chain,#
  n.iter = N_iter + N_burn,#
  n.burnin = N_burn, #floor(n.iter/2)#
  n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
  DIC = TRUE,#
  working.directory = NULL,#
  jags.seed = 123,#
  refresh = N_iter/50,#
  progress.bar = "text",#
  digits = 5,#
  RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
  jags.module = c("glm","dic")#
)
library(R2jags)#
#
# This is code to estimate some model parameters for proportional abundance of DNA in a sample given reads in the file from a sequencer#
# Let:#
# i = taxon i (1:I); Carkeek grid dataset I = ? (limit to 10 for tests)#
# j = PCR replicate j (1:J); Carkeek grid dataset J = 4#
# k = location k (1:K); Carkeek grid dataset K = 24#
# Requires as input:#
# 1. otu file#
# 2. metadata file#
#
# a table of counts of sequences (Z, length = ...)#
counts_table <- read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/OTUs_top10_4000m.csv", row.names = 1)#
# rows/rownames = samples, columns/colnames = taxa, cells = integer counts#
# if table is incorrectly oriented, transpose it:#
# counts_table <- as.data.frame(t(counts_table))#
#
# load metadata#
metadata <- read.csv("/Users/threeprime/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Data/metadata_spatial.csv", stringsAsFactors = FALSE)#
#
# what is the name of the column containing the sample id (SEQUENCING samples)#
colname_sampleid <- "sample_id"#
#
# what is the name of the column containing PCR replicate levels#
colname_pcr <- "PCR_replicate"#
#
# what is the name of the column containing relevant site replicate levels#
colname_site <- "transect"#
#
# of each taxon (length = I)#
taxa <- colnames(counts_table)#
#
# from each PCR replicate (length = J)#
pcr <- unique(metadata[, colname_pcr])#
#
# at each site (length = K)#
sites <- unique(metadata[, colname_site])#
# JAGS won't do some basic R functions, so we need to give it the lengths explicitly#
N_taxa <- length(taxa)#
N_pcr <- length(pcr)#
N_sites <- length(sites)#
# make a vector of the site for each sample name in the counts table#
site_by_rowname <- metadata[ , colname_site][#
  match(rownames(counts_table), metadata[ , colname_sampleid])#
  ]#
#
# unused for now#
# sampleid_by_site <- split(x = metadata[, colname_sampleid], f = metadata[, colname_site], drop = TRUE)#
#
counts_by_site <- split(x = counts_table, f = site_by_rowname)#
# create an array for JAGS called "counts"#
# where counts[j,i,k] is the counts in pcr replicate j of taxon i at site k#
counts <- array(#
  data = unlist(counts_by_site),#
  dim = c(length(pcr), length(taxa), length(sites)),#
  dimnames = list(#
    pcr = pcr,#
    taxa = taxa,#
    sites = sites#
  )#
)#
#
# this really should be a function like this...#
# JAGSarray3D <- function(table, split_vector){#
##
# }#
#
# thus, you should be able to reference stuff like so:#
counts[ pcr[4] ,         ,          ]#
counts[        , taxa[8] ,          ]#
counts[        ,         , sites[2] ]#
#
# lambda = mean of the Poisson dist that describes variation in counts#
# beta = intercept#
# eta = random effect for i,j,k#
# sigma2 = variance of normal distribution describing eta (attributable to PCR)#
#
# epsilon = random effect for i,k#
# tau2 = variance of normal distribution describing epsilon (attributable to location - k)#
#
# gamma = coefficient of something, I think -- maybe the covariate matrix?#
# phi =#
#
# pi = proportional abundance of each taxon#
#
# counts <- counts_table#
#
model_loc <- c("jags_model_multi_location.txt")#
#
jags.model()#
jagsscript <- cat(#
"#
  model {#
#
  ## MODEL STRUCTURE#
  for(k in 1:N_sites){#
    for(i in 1:N_taxa){#
      for(j in 1:N_pcr){#
#
      # Likelihood function#
      counts[j,i,k] ~ dpois(exp(lambda[j,i,k]))#
#
      # GLM#
      lambda[j,i,k] <- beta_0 + beta[i] + eta[j,i,k] + epsilon[j,i,k]#
      # alt:#
      # fixed[i,j] <- beta_0 + beta[i]#
      # lambda[i,j] <- fixed[i] + eta[i,j]#
#
      # note that precision = 1/variance and variance = sd^2#
      # mu = mean, tau = precision#
      eta[j,i,k] ~ dnorm(0, 1/sigma2)#
#
      epsilson[j,i,k] ~ dnorm(0, 1/tau2)#
#
      }#
    }#
  }#
#
  ## PRIORS#
#
  # the general intercept (mean of counts of all taxa for all PCR replicates)#
  beta_0 ~ dnorm(0, 1/1000)#
#
  # beta[1] must be zero, because for taxa[1]#
  beta[1] <- 0#
#
  for(i in 2:N_taxa){#
  # mu = mean, tau = precision#
  beta[i] ~ dnorm(0, 1/1000)#
  }#
#
  # to allow variance attributable to PCR to vary among species#
  # for(i in 1:N_taxa){#
  # in JAGS gamma, shape = r and rate = mu (lambda?)#
  sigma2 ~ dgamma(0.01, 0.01)#
  # }#
#
  tau2 ~ dgamma(0.01, 0.01)#
#
  ## DERIVED QUANTITIES#
  # i.e. estimated proportion of taxa[i]#
#
  # multinomial poisson transformation#
  for(i in 1:N_taxa){#
    p[i] <- exp(beta_0 + beta[i])#
  }#
#
  for(i in 1:N_taxa){#
    P[i] <- p[i] / sum(p)#
  }#
#
  }#
  ",#
  file = model_loc#
)#
jags_data <- list(#
  "counts",#
  "N_taxa",#
  "N_pcr"#
)#
#
jags_params <- c(#
  "beta",#
  "sigma2",#
  "tau2",#
  "P",#
  "beta_0"#
)#
N_burn <- 1000#
#
N_iter <- 1000#
#
N_chain <- 3#
#
my_jags <- jags(#
  data = jags_data,#
  inits = NULL,#
  parameters.to.save = jags_params,#
  model.file = model_loc,#
  n.chains = N_chain,#
  n.iter = N_iter + N_burn,#
  n.burnin = N_burn, #floor(n.iter/2)#
  n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
  DIC = TRUE,#
  working.directory = NULL,#
  jags.seed = 123,#
  refresh = N_iter/50,#
  progress.bar = "text",#
  digits = 5,#
  RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
  jags.module = c("glm","dic")#
)
k
N_sites
dim(counts)
dimnames(counts)
require(rjags)
counts[,,1]
library(R2jags)#
#
setwd("~/Documents/GoogleDrive/Kelly_Lab/Projects/Carkeek_eDNA_grid/Analysis")#
#
data_dir <- file.path("..", "Data")#
fig_dir <- file.path("..", "Figures")#
#
# Let:#
# i = taxon i (1:I); Carkeek grid dataset I = ? (limit to 10 for tests)#
# j = PCR replicate j (1:J); Carkeek grid dataset J = 4#
# k = location k (1:K); Carkeek grid dataset K = 24#
# Requires as input:#
# 1. otu file#
# 2. metadata file#
#
# a table of counts of sequences (Z, length = ...)#
counts_file_path <- file.path(data_dir, "OTUs_top10_4000m.csv")#
counts_table <- read.csv(file = counts_file_path, row.names = 1)#
# rows/rownames = samples, columns/colnames = taxa, cells = integer counts#
# if table is incorrectly oriented, transpose it:#
# counts_table <- as.data.frame(t(counts_table))#
#
# load metadata#
metadata_file_path <- file.path(data_dir, "metadata_spatial.csv")#
metadata <- read.csv(file = metadata_file_path, stringsAsFactors = FALSE)#
#
# what is the name of the column containing the sample id (SEQUENCING samples)#
colname_sampleid <- "sample_id"#
#
# what is the name of the column containing PCR replicate levels#
colname_pcr <- "PCR_replicate"#
#
# what is the name of the column containing relevant site replicate levels#
colname_site <- "transect"#
#
# of each taxon (length = I)#
taxa <- colnames(counts_table)#
#
# from each PCR replicate (length = J)#
pcr <- unique(metadata[, colname_pcr])#
#
# at each site (length = K)#
sites <- unique(metadata[, colname_site])#
# JAGS won't do some basic R functions, so we need to give it the lengths explicitly#
N_taxa <- length(taxa)#
N_pcr <- length(pcr)#
N_sites <- length(sites)#
# make a vector of the site for each sample name in the counts table#
site_by_rowname <- metadata[ , colname_site][#
  match(rownames(counts_table), metadata[ , colname_sampleid])#
  ]#
#
# unused for now#
# sampleid_by_site <- split(x = metadata[, colname_sampleid], f = metadata[, colname_site], drop = TRUE)#
#
counts_by_site <- split(x = counts_table, f = site_by_rowname)#
# create an array for JAGS called "counts"#
# where counts[j,i,k] is the counts in pcr replicate j of taxon i at site k#
counts <- array(#
  data = unlist(counts_by_site),#
  dim = c(length(pcr), length(taxa), length(sites)),#
  dimnames = list(#
    pcr = pcr,#
    taxa = taxa,#
    sites = sites#
  )#
)#
#
# this really should be a function like this...#
# JAGSarray3D <- function(table, split_vector){#
##
# }#
#
# thus, you should be able to reference stuff like so:#
counts[ pcr[4] ,         ,          ]#
counts[        , taxa[8] ,          ]#
counts[        ,         , sites[2] ]
counts[,,1]
class(counts[,,1])
dim(counts[,,1])
counts
counts <- counts[,,1]
counts
model_loc <- "eDNA_model_single.txt"#
#
jagsscript <- cat(#
"#
  model {#
#
  ## MODEL STRUCTURE#
  # for(k in 1:N_sites){#
    for(i in 1:N_taxa){#
      for(j in 1:N_pcr){#
#
      # Likelihood function#
      # counts[j,i,k] ~ dpois(exp(lambda[j,i,k]))#
      counts[j,i] ~ dpois(exp(lambda[j,i]))#
#
      # GLM#
      # lambda[j,i,k] <- beta_0 + beta[i] + eta[j,i,k] + epsilon[j,i,k]#
      # single site: #
      lambda[j,i] <- beta_0 + beta[,i] + eta[j,i]#
      # alt format:#
      # fixed[i,j] <- beta_0 + beta[i]#
      # lambda[i,j] <- fixed[i] + eta[i,j]#
#
      # random effect for i,j#
      # note that precision = 1/variance and variance = sd^2#
      # mu = mean, tau = precision#
      # eta[j,i,k] ~ dnorm(0, 1/sigma2)#
      eta[j,i] ~ dnorm(0, 1/sigma2) # single site (k)#
#
      # random effect for i,k#
      # epsilson[j,i,k] ~ dnorm(0, 1/tau2)#
#
      }#
    }#
  }#
#
  ## PRIORS#
  # *NOTE: in JAGS gamma, shape = r and rate = mu (lambda?)#
#
  # the general intercept (mean of counts of all taxa for all PCR replicates)#
  beta_0 ~ dnorm(0, 1/1000)#
#
  # beta[1] must be zero, because for taxa[1]#
  beta[1] <- 0#
#
  for(i in 2:N_taxa){#
    # mu = mean, tau = precision#
    beta[,i] ~ dnorm(0, 1/1000)#
  }#
#
  # to allow variance attributable to PCR to vary among species#
  # can make this species-specific by adding [i] and looping#
  # for(i in 1:N_taxa){#
  # in JAGS gamma, shape = r and rate = mu (lambda?)#
  sigma2 ~ dgamma(0.01, 0.01)#
  # }#
#
  # in JAGS gamma, shape = r and rate = mu (lambda?)#
  # tau2 ~ dgamma(0.01, 0.01)#
#
  ## DERIVED QUANTITIES#
#
  # multinomial poisson transformation#
  # i.e. estimated proportion of taxa[i]#
  for(i in 1:N_taxa){#
    p[i] <- exp(beta_0 + beta[i])#
  }#
#
  for(i in 1:N_taxa){#
    P[i] <- p[i] / sum(p)#
  }#
#
  }#
  ",#
  file = model_loc#
)#
#
jags_data <- list(#
  "counts",#
  "N_taxa",#
  "N_pcr"#
  # "N_sites"#
)#
#
jags_params <- c(#
  "beta",#
  "sigma2",#
  # "tau2",#
  "P",#
  "beta_0"#
)#
N_burn <- 1000#
#
N_iter <- 1000#
#
N_chain <- 3#
#
my_jags <- jags(#
  data = jags_data,#
  inits = NULL,#
  parameters.to.save = jags_params,#
  model.file = model_loc,#
  n.chains = N_chain,#
  n.iter = N_iter + N_burn,#
  n.burnin = N_burn, #floor(n.iter/2)#
  n.thin = 1, # max(1, floor((n.iter - n.burnin)/1000))#
  DIC = TRUE,#
  working.directory = NULL,#
  jags.seed = 123,#
  refresh = N_iter/50,#
  progress.bar = "text",#
  digits = 5,#
  RNGname = c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper", "Mersenne-Twister"),#
  jags.module = c("glm","dic")#
)
